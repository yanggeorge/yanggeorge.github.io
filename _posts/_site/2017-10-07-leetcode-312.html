<h2 id="目录">目录</h2>

<ul>
  <li><a href="#hh0">题目概述</a></li>
  <li><a href="#hh1">简单直接的解法</a></li>
  <li><a href="#hh2">回顾矩阵链解法</a></li>
  <li><a href="#hh3">等价转换</a></li>
</ul>

<h2 id="-题目概述"><a name="hh0"></a> 题目概述</h2>

<p> 
 
 
 
<a href="https://leetcode.com/problems/burst-balloons/">312原题链接</a></p>

<blockquote>
  <p>Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.</p>

  <p>Find the maximum coins you can collect by bursting the balloons wisely.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>examples:
nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []
coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
</code></pre>
</div>

<h2 id="-简单直接的解法"><a name="hh1"></a> 简单直接的解法</h2>

<p> 
 
 
 
遍历回溯法，建立一个集合，把遍历过的数字放在该集合里。算法的复杂度是O(n!)。解法如下</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Solution1</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">maxCoins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="s">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">max_path</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span><span class="p">]</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">D</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">max_path</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">max_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">max_path</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="nb">max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">max_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span><span class="p">[:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span>
                    <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">D</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
                    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmp</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">max_path</span><span class="p">)</span>
                    <span class="n">path</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">D</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">tmp</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">D</span><span class="p">):</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">*</span> <span class="n">right</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="-回顾矩阵链解法"><a name="hh2"></a> 回顾矩阵链解法</h2>

<p> 
 
 
 
以上的方法无疑会超时，但是它是我们理解问题，验证其它算法的基础。
我们希望能够得到一个多项式时间的解法，按照以往的经验，我们如果能够找到一个贪心算法是最好的，
但是如果我们能够有一个贪心算法，那么也一定能够有一个动态规划方法。<code class="highlighter-rouge">CRLS</code>对贪心和动态规划做了清楚的
描述，核心都是要找到最优子结构，并且证明存在最优子结构——这其实也是最难的部分，<code class="highlighter-rouge">因为动态规划方法从来只是一个思想，本质上不过是
递归的一种优化而已</code>。</p>

<p> 
 
 
 
<code class="highlighter-rouge">CRLS</code>中在动态规划一章中用了几个例子来详细展示动态规划方法。其中第二个例子就是矩阵链问题————如果有一个
矩阵链<code class="highlighter-rouge">A1*A2*A3*A4</code>，其中A1是1x5的矩阵，A2是5x1的矩阵，A3是1x5的矩阵，A4是5x1的矩阵。那么先计算<code class="highlighter-rouge">A1*A2</code>和<code class="highlighter-rouge">A3*A4</code>
则是比较好的，代价较小都是<code class="highlighter-rouge">1x5x1=5</code>。而<code class="highlighter-rouge">A2*A3</code>则是比较糟糕的，因为<code class="highlighter-rouge">A2*A3</code>的计算代价是<code class="highlighter-rouge">5x1x5=25</code>。</p>

<blockquote>
  <p>对给定的两个矩阵相乘<code class="highlighter-rouge">A_ik*A_kj</code>,
计算的代价是<code class="highlighter-rouge">i*k*j</code>。</p>
</blockquote>

<h2 id="-等价转换"><a name="hh3"></a> 等价转换</h2>

<p> 
 
 
 
矩阵链中计算的代价是三个数相乘，而我们这里也是三个数字相乘。对于三个气球（数字）<code class="highlighter-rouge">5·1·5</code>，如果戳破第一个气球（数字），则得分（代价）是1x5x1，如果戳破第二个气球（数字）
得分（代价）是5x1x5，戳破第三个气球（数字）得分（代价）是1x5x1。对于1x5x1可以转换为1x5的矩阵和5x1的矩阵的代价。
5x1x5，可以转换为5x1的矩阵和1x5的矩阵的代价。最终，三个数字<code class="highlighter-rouge">5·1·5</code>可以等价转换为求解四个矩阵
<code class="highlighter-rouge">A1*A2*A3*A4</code>的最大计算代价的问题。所以第一步就是把n个数字转换为n+1个矩阵表示，第二步就是把矩阵链问题的递归求解中
的min改成max。如果这两个问题是等价的，那么我们的解法一定可以通过测试。并且似乎也不用去证明了。（其实这是最难的部分。）</p>

<p>以下是通过的<code class="highlighter-rouge">memoization</code>解法，算法的复杂度是O(n^2)，与矩阵链问题的复杂度一样：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Solution2</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">maxCoins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="s">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="nb">list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="c"># 转换为n+1个矩阵的表示。每个pair tuple对应矩阵的长和宽。</span>
        <span class="k">print</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="c"># 声明一个子问题空间是n^2的记忆体</span>
        <span class="k">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">recursive</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="nb">list</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
                <span class="nb">list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">list</span>

    <span class="k">def</span> <span class="nf">recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">max</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recursive</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recursive</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="nb">list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">list</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="nb">max</span> <span class="p">:</span>
                    <span class="nb">max</span> <span class="o">=</span> <span class="n">v</span>
            <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span>
            <span class="k">return</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

