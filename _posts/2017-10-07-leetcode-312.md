---
layout: post
title: "[leetcode 312]Burst Balloons原创解法"
categories: leetcode 算法 python
author: alenym@qq.com
---
## 目录 ##

- [题目概述](#hh0) 
- [简单直接的解法](#hh1) 
- [回顾矩阵链解法](#hh2) 
- [等价转换](#hh3) 

## <a name="hh0"></a> 题目概述 ##

&nbsp;
&nbsp;
&nbsp;
&nbsp;
[312原题链接](https://leetcode.com/problems/burst-balloons/)


> Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.
> 
> Find the maximum coins you can collect by bursting the balloons wisely.
	
	examples:
	nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
	coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167


## <a name="hh1"></a> 简单直接的解法 ##

&nbsp;
&nbsp;
&nbsp;
&nbsp;
遍历回溯法，建立一个集合，把遍历过的数字放在该集合里。算法的复杂度是O(n!)。解法如下


{% highlight python linenos %}
class Solution1(object):
    def maxCoins(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        path = []
        max_path = [path]
        max = [0]
        s = [0]
        D = set()
        self.find(nums, path, D, s, max, max_path)
        print(max_path[0])
        return max[0]

    def find(self, nums, path, D, s, max, max_path):
        if len(path) == len(nums):
            if s[0] > max[0]:
                max[0] = s[0]
                max_path[0] = path[:]
        else:
            for i in range(len(nums)):
                if i not in D:
                    path.append(i)
                    D.add(i)
                    tmp = self.compute(i, nums, D)
                    s[0] += tmp
                    self.find(nums, path, D, s, max, max_path)
                    path.pop()
                    D.remove(i)
                    s[0] -= tmp

    def compute(self, i, nums, D):
        left, right = 1, 1
        for j in range(i - 1, -1, -1):
            if j not in D:
                left = nums[j]
                break
        for k in range(i + 1, len(nums)):
            if k not in D:
                right = nums[k]
                break
        return left * right * nums[i]
{% endhighlight %}

## <a name="hh2"></a> 回顾矩阵链解法 ##

&nbsp;
&nbsp;
&nbsp;
&nbsp;
以上的方法无疑会超时，但是它是我们理解问题，验证其它算法的基础。
我们希望能够得到一个多项式时间的解法，按照以往的经验，我们如果能够找到一个贪心算法是最好的，
但是如果我们能够有一个贪心算法，那么也一定能够有一个动态规划方法。`CRLS`对贪心和动态规划做了清楚的
描述，核心都是要找到最优子结构。


&nbsp;
&nbsp;
&nbsp;
&nbsp;
`CRLS`中在动态规划一章中用了几个例子来详细展示动态规划方法。第二个例子就是矩阵链的问题。例如如果有一个
矩阵链`A1*A2*A3*A4`，其中A1是1x5的矩阵，A2是5x1的矩阵，A3是1x5的矩阵，A4是5x1的矩阵。那么先计算`A1*A2`和`A3*A4`
则是比较好的。而`A2*A3`则是比较糟糕的，因为`A2*A3`的计算代价是`5x1x5=25`。对给定的两个矩阵相乘`A_ik*A_kl`,
计算的代价是`i*k*l`。


## <a name="hh3"></a> 等价转换 ##

&nbsp;
&nbsp;
&nbsp;
&nbsp;
那么与我们的问题进行比较会发现相似之处。对于三个数字`5·1·5`，如果戳破第一个数字，则代价是1x5x1，如果戳破第二个数字
代价是5x1x5，戳破第三个数字代价是1x5x1。因此可以大胆的猜测两个问题是等价的。只不过一个是求解最小的代价，一个是求解
最大的代价。

以下是通过的`memoization`解法：


{% highlight python linenos %}
class Solution2(object):
    def maxCoins(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        list = self.get(nums)
        print(list)
        n += 1
        m = [[None] * n for i in range(n)]
        print(m)
        for i in range(n):
            m[i][i] = 0

        return self.recursive(list, m, 0, n - 1)

    def get(self, nums):
        n = len(nums)
        list = [(1, nums[0])]
        for i in range(n):
            if (i + 1 < n):
                list.append((nums[i], nums[i + 1]))
            else:
                list.append((nums[i], 1))
        return list

    def recursive(self, list, m, i, j):
        if m[i][j] is not None:
            return m[i][j]
        else:
            max = -1
            for k in range(i, j):
                a = self.recursive(list, m, i, k)
                b = self.recursive(list, m, k + 1, j)
                v = a + b + list[i][0] * list[k][1] * list[j][1]
                if v > max :
                    max = v
            m[i][j] = max
            return m[i][j]
{% endhighlight %}
