<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Write a simple parser for MiniLisp by using JavaCC</title>
  <meta name="description" content="目录">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="/java/javacc/lisp/2017/05/19/javacc-minilisp.html">
  <link rel="alternate" type="application/rss+xml" title="3.λ｜形而下技术博客" href="/feed.xml">
  
  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102303390-1', 'auto');
  ga('send', 'pageview');

</script>

  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">3.λ｜形而下技术博客</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">关于作者</a>
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Write a simple parser for MiniLisp by using JavaCC</h1>
    <p class="post-meta"><time datetime="2017-05-19T00:00:00+00:00" itemprop="datePublished">May 19, 2017</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">alenym@qq.com</span></span></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h2 id="目录">目录</h2>

<ul>
  <li><a href="#hh0">MiniLisp是什么？</a></li>
  <li><a href="#hh1">JavaCC是什么？</a></li>
  <li><a href="#hh2">MiniLisp的BNF语法描述没有怎么办？</a></li>
  <li><a href="#hh3">MiniLisp的jj文件</a></li>
  <li><a href="#hh4">测试代码</a></li>
</ul>

<h2 id="-minilisp是什么"><a name="hh0"></a> MiniLisp是什么？</h2>

<p> 
 
 
 
<a href="https://github.com/rui314/minilisp">MiniLisp</a>是一个只用几百行代码实现的Lisp。以下是实现的
基本特性。</p>

<ul>
  <li>integers, symbols, cons cells,</li>
  <li>global variables,</li>
  <li>lexically-scoped local variables,</li>
  <li>closures,</li>
  <li>if conditional,</li>
  <li>primitive functions, such as +, =, &lt;, or list,</li>
  <li>user-defined functions,</li>
  <li>a macro system,</li>
  <li>and a copying garbage collector.</li>
</ul>

<p> 
 
 
 
在笔者看来真是麻雀虽小五脏俱全啊。这是一个非常值得研究的项目。</p>

<h2 id="-javacc是什么"><a name="hh1"></a> JavaCC是什么？</h2>

<p> 
 
 
 
<a href="https://javacc.org/">JavaCC</a>据说是一个非常易用好理解的<code class="highlighter-rouge">LL(k)</code>的Parser生成工具。
说它好理解是指它生成的Java代码要比<code class="highlighter-rouge">LR</code>类型的容易理解。毕竟<code class="highlighter-rouge">LL</code>是<code class="highlighter-rouge">Top-Down Parser</code>呀。
笔者以前只用过<code class="highlighter-rouge">LR(1)</code>类型的工具，<code class="highlighter-rouge">JavaCC</code>则从来没用过。</p>

<h2 id="-minilisp的bnf语法描述没有怎么办"><a name="hh2"></a> MiniLisp的BNF语法描述没有怎么办？</h2>

<p> 
 
 
 
<code class="highlighter-rouge">MiniLisp</code>的作者并没有使用<code class="highlighter-rouge">yacc</code>等工具，而是自己手写的<code class="highlighter-rouge">Top-Down Parser</code>。所以无法得到
<code class="highlighter-rouge">MiniLisp</code>的BNF描述。</p>

<p> 
 
 
 
没关系，既然是Lisp方言，那么先看看传统的Lisp的BNF语法是什么。这里有一个简单的BNF版本
<a href="http://cui.unige.ch/isi/bnf/LISP/BNFlisp.html">BNF rules of LISP</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>s_expression = atomic_symbol \
              / "(" s_expression "."s_expression ")" \
              / list 

list = "(" s_expression &lt; s_expression &gt; ")"

atomic_symbol = letter atom_part

atom_part = empty / letter atom_part / number atom_part

letter = "a" / "b" / " ..." / "z"

number = "1" / "2" / " ..." / "9"

empty = " "
</code></pre>
</div>

<p>想要实现MiniLisp的Parser，首先要理解这个BNF规则。</p>

<h2 id="-minilisp的jj文件"><a name="hh3"></a> MiniLisp的jj文件</h2>

<p> 
 
 
 
以下是用JavaCC生成MiniLisp
 Parser的jj文件。用javacc编译之后，会报一个警告<code class="highlighter-rouge">117行和118行发生conflict</code>。但是笔者已经加上<code class="highlighter-rouge">LOOKAHEAD(2)</code>了。
不知道为什么还警告，而且也单独对这部分进行了测试，完全没有问题。另外，这个生成的Parser并没有构造AST。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121</pre></td><td class="code"><pre><span class="n">options</span> <span class="o">{</span>
  <span class="n">STATIC</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="n">DEBUG_PARSER</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="n">DEBUG_LOOKAHEAD</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="n">DEBUG_TOKEN_MANAGER</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="n">ERROR_REPORTING</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="n">JAVA_UNICODE_ESCAPE</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="n">UNICODE_INPUT</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="n">IGNORE_CASE</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="n">USER_TOKEN_MANAGER</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="n">USER_CHAR_STREAM</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="n">BUILD_PARSER</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="n">BUILD_TOKEN_MANAGER</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="n">SANITY_CHECK</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="n">FORCE_LA_CHECK</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>

<span class="n">PARSER_BEGIN</span><span class="o">(</span><span class="n">MiniLisp</span><span class="o">)</span>

<span class="kn">package</span> <span class="n">ym</span><span class="o">.</span><span class="na">minilisp</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">ym.minilisp.node.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MiniLisp</span> <span class="o">{</span>

  <span class="cm">/** Main entry point. */</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[])</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
    <span class="n">MiniLisp</span> <span class="n">parser</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MiniLisp</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
    <span class="n">parser</span><span class="o">.</span><span class="na">Input</span><span class="o">();</span>
  <span class="o">}</span>

<span class="o">}</span>
<span class="n">PARSER_END</span><span class="o">(</span><span class="n">MiniLisp</span><span class="o">)</span>


<span class="n">TOKEN</span> <span class="o">:</span>
<span class="o">{</span>
      <span class="o">&lt;</span><span class="nl">EMPTY:</span> <span class="o">[</span><span class="s">" "</span><span class="o">,</span><span class="s">"\t"</span><span class="o">,</span><span class="s">"\n"</span><span class="o">,</span><span class="s">"\r"</span><span class="o">]</span> <span class="o">([</span><span class="s">" "</span><span class="o">,</span><span class="s">"\t"</span><span class="o">,</span><span class="s">"\n"</span><span class="o">,</span><span class="s">"\r"</span><span class="o">])*&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">LP:</span> <span class="s">"("</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">RP:</span> <span class="s">")"</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">DOT:</span> <span class="s">"."</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">MINUS:</span> <span class="s">"-"</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">PLUS:</span> <span class="s">"+"</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">EQ:</span> <span class="s">"="</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">AND:</span> <span class="s">"and"</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">NOT:</span> <span class="s">"not"</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">OR:</span> <span class="s">"or"</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">GT:</span> <span class="s">"&gt;"</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">LT:</span> <span class="s">"&lt;"</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">LE:</span> <span class="s">"&lt;="</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">GE:</span> <span class="s">"&gt;="</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">SQUOTE:</span> <span class="s">"'"</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">QUOTE:</span> <span class="s">"quote"</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">NUM:</span> <span class="o">[</span><span class="s">"1"</span><span class="o">-</span><span class="s">"9"</span><span class="o">]</span> <span class="o">(</span> <span class="o">[</span><span class="s">"0"</span><span class="o">-</span><span class="s">"9"</span><span class="o">]</span> <span class="o">)*</span> <span class="o">|</span> <span class="s">"0"</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">ID:</span> <span class="o">([</span><span class="s">"a"</span><span class="o">-</span><span class="s">"z"</span><span class="o">,</span><span class="s">"A"</span><span class="o">-</span><span class="s">"Z"</span><span class="o">,</span><span class="s">"_"</span><span class="o">,</span><span class="s">"@"</span><span class="o">,</span><span class="s">"?"</span><span class="o">,</span><span class="s">"$"</span><span class="o">,</span><span class="s">"%"</span><span class="o">,</span><span class="s">"*"</span><span class="o">])</span> <span class="o">(~[</span><span class="s">"\n"</span><span class="o">,</span><span class="s">"\r"</span><span class="o">,</span><span class="s">" "</span><span class="o">,</span><span class="s">"("</span><span class="o">,</span><span class="s">")"</span><span class="o">,</span><span class="s">"\t"</span><span class="o">,</span><span class="s">"#"</span><span class="o">,</span><span class="s">";"</span><span class="o">,</span><span class="s">"{"</span><span class="o">,</span><span class="s">"}"</span><span class="o">,</span><span class="s">"["</span><span class="o">,</span><span class="s">"]"</span><span class="o">])*</span> <span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nl">COMMENT:</span> <span class="o">([</span><span class="s">";"</span><span class="o">])(~[</span><span class="s">"\n"</span><span class="o">,</span><span class="s">"\r"</span><span class="o">])*</span> <span class="o">[</span><span class="s">"\n"</span><span class="o">,</span><span class="s">"\r"</span><span class="o">]&gt;</span>
<span class="o">}</span>


<span class="cm">/** Root production. */</span>
<span class="kt">void</span> <span class="nf">Input</span><span class="o">()</span> <span class="o">:</span>
<span class="o">{}</span>
<span class="o">{</span>
    <span class="o">(</span> <span class="n">Expr</span><span class="o">()</span> <span class="o">)*</span>  <span class="o">&lt;</span><span class="n">EOF</span><span class="o">&gt;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">Expr</span><span class="o">():</span>
<span class="o">{}</span>
<span class="o">{</span>
      <span class="n">NonSExpr</span><span class="o">()</span>
    <span class="o">|</span> <span class="n">SExpr</span><span class="o">()</span>
<span class="o">}</span>


<span class="kt">void</span> <span class="nf">NonSExpr</span><span class="o">():</span>
<span class="o">{}</span>
<span class="o">{</span>
    <span class="o">&lt;</span><span class="n">EMPTY</span><span class="o">&gt;</span>
   <span class="o">|&lt;</span><span class="n">COMMENT</span><span class="o">&gt;</span>
<span class="o">}</span>


<span class="kt">void</span> <span class="nf">SExpr</span><span class="o">()</span> <span class="o">:</span>
<span class="o">{}</span>
<span class="o">{</span>
      <span class="n">SymbolExpr</span><span class="o">()</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="n">LP</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">NonSExpr</span><span class="o">())*</span> <span class="o">(</span><span class="n">SExpr</span><span class="o">()</span> <span class="o">(</span><span class="n">NonSExpr</span><span class="o">())*</span> <span class="o">)*</span>  <span class="o">[&lt;</span><span class="n">DOT</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">NonSExpr</span><span class="o">())*</span>  <span class="o">(</span><span class="n">SExpr</span><span class="o">()</span> <span class="o">(</span><span class="n">NonSExpr</span><span class="o">())*</span> <span class="o">)*]</span> <span class="o">&lt;</span><span class="n">RP</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="n">SQuoteExpr</span><span class="o">()</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">SQuoteExpr</span><span class="o">():</span>
<span class="o">{}</span>
<span class="o">{</span>
    <span class="o">&lt;</span><span class="n">SQUOTE</span><span class="o">&gt;</span> <span class="nf">SExpr</span><span class="o">()</span>
<span class="o">}</span>


<span class="kt">void</span> <span class="nf">SymbolExpr</span><span class="o">():</span>
<span class="o">{}</span>
<span class="o">{</span>
    <span class="n">Symbol</span><span class="o">()</span> <span class="n">LOOKAHEAD</span><span class="o">({</span> <span class="n">getToken</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">kind</span> <span class="o">==</span> <span class="n">LP</span> <span class="o">||</span> <span class="n">getToken</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">kind</span> <span class="o">==</span> <span class="n">RP</span><span class="o">||</span> <span class="n">getToken</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">kind</span> <span class="o">==</span> <span class="n">DOT</span> <span class="o">||</span> <span class="n">getToken</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">kind</span> <span class="o">==</span> <span class="n">COMMENT</span> <span class="o">||</span> <span class="n">getToken</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">kind</span> <span class="o">==</span> <span class="n">EMPTY</span> <span class="o">})</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">Symbol</span><span class="o">():</span>
<span class="o">{}</span>
<span class="o">{</span>
       <span class="o">&lt;</span><span class="n">PLUS</span><span class="o">&gt;</span>
    <span class="o">|</span>  <span class="o">&lt;</span><span class="n">EQ</span><span class="o">&gt;</span>
    <span class="o">|</span>  <span class="o">&lt;</span><span class="n">AND</span><span class="o">&gt;</span>
    <span class="o">|</span>  <span class="o">&lt;</span><span class="n">NOT</span><span class="o">&gt;</span>
    <span class="o">|</span>  <span class="o">&lt;</span><span class="n">OR</span><span class="o">&gt;</span>
    <span class="o">|</span>  <span class="o">&lt;</span><span class="n">GT</span><span class="o">&gt;</span>
    <span class="o">|</span>  <span class="o">&lt;</span><span class="n">LT</span><span class="o">&gt;</span>
    <span class="o">|</span>  <span class="o">&lt;</span><span class="n">LE</span><span class="o">&gt;</span>
    <span class="o">|</span>  <span class="o">&lt;</span><span class="n">GE</span><span class="o">&gt;</span>
    <span class="o">|</span>  <span class="n">LOOKAHEAD</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">&lt;</span><span class="n">MINUS</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">NUM</span><span class="o">&gt;</span>
    <span class="o">|</span>  <span class="o">&lt;</span><span class="n">MINUS</span><span class="o">&gt;</span>
    <span class="o">|</span>  <span class="o">&lt;</span><span class="n">NUM</span><span class="o">&gt;</span>
    <span class="o">|</span>  <span class="o">&lt;</span><span class="n">ID</span><span class="o">&gt;</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="-测试代码"><a name="hh4"></a> 测试代码</h2>

<p> 
 
 
 
以下是对生成的MiniLisp.java文件进行测试的类。其中<code class="highlighter-rouge">test14</code>和<code class="highlighter-rouge">test15</code>是对
MiniLisp项目下的life.lisp和nqueens.lisp文件内容完整解析测试。
没有报错，说明jj中的规则可以解析MiniLisp。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506</pre></td><td class="code"><pre><span class="kn">package</span> <span class="n">ym</span><span class="o">.</span><span class="na">minilisp</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.StringReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">junit.framework.TestCase</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestParser</span> <span class="kd">extends</span> <span class="n">TestCase</span> <span class="o">{</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"((a.b).(b.(c)))"</span><span class="o">;</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"(a b c)"</span><span class="o">;</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">"(a b . c)"</span><span class="o">;</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test3</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"(a .(b c))"</span><span class="o">;</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test4</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">" ( ( a b ) . ( b c ) ) "</span><span class="o">;</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test5</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"( a ( a b )  ( b c ) ) "</span><span class="o">;</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test6</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"(define a 1) (define b -1) "</span><span class="o">;</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test7</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">" (+ 1 -2 a b (- 1 2)) "</span><span class="o">;</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test8</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">" (defun next (board x y)\n"</span>
                <span class="o">+</span> <span class="s">"  (let c (count board x y)\n"</span>
                <span class="o">+</span> <span class="s">"       (if (alive? board x y)\n"</span>
                <span class="o">+</span> <span class="s">"           (or (= c 2) (= c 3))\n"</span>
                <span class="o">+</span> <span class="s">"         (= c 3))))"</span><span class="o">;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test9</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"(defun count (board x y)\n"</span>
                <span class="o">+</span> <span class="s">"  (let at (lambda (x y)\n"</span>
                <span class="o">+</span> <span class="s">"            (if (alive? board x y) 1 0))\n"</span>
                <span class="o">+</span> <span class="s">"       (+ (at (- x 1) (- y 1))\n"</span>
                <span class="o">+</span> <span class="s">"          (at (- x 1) y)\n"</span>
                <span class="o">+</span> <span class="s">"          (at (- x 1) (+ y 1))\n"</span>
                <span class="o">+</span> <span class="s">"          (at x (- y 1))\n"</span>
                <span class="o">+</span> <span class="s">"          (at x (+ y 1))\n"</span>
                <span class="o">+</span> <span class="s">"          (at (+ x 1) (- y 1))\n"</span>
                <span class="o">+</span> <span class="s">"          (at (+ x 1) y)\n"</span>
                <span class="o">+</span> <span class="s">"          (at (+ x 1) (+ y 1)))))"</span><span class="o">;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test10</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">" '(+ 1 2) "</span><span class="o">;</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test11</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"(cons '1 '2)"</span><span class="o">;</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test12</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"(defmacro progn (expr . rest)\n"</span>
                <span class="o">+</span> <span class="s">"  (list (cons 'lambda (cons () (cons expr rest)))))"</span><span class="o">;</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test13</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">";;fadfsdfasdfasdfasdfa\n"</span>
                <span class="o">+</span> <span class="s">"(cons '1 '2)"</span><span class="o">;</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test131</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"(cons ;;fadfsdfasdfasdfasdfa\n"</span>
                <span class="o">+</span> <span class="s">"  '1 '2)"</span><span class="o">;</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test132</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">";;fadfsdfasdfasdfasdfa\n"</span>
                <span class="o">+</span> <span class="s">"  \n"</span>
                <span class="o">+</span> <span class="s">";;fadfsdfasdfasdfasdf\n"</span><span class="o">;</span>

        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test133</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"(list ;;fadfsdfasdfasdfasdfa\n"</span>
                <span class="o">+</span> <span class="s">"  a  ;;fadfsdfasdfasdfasdfa\n "</span>
                <span class="o">+</span> <span class="s">"b)"</span><span class="o">;</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test14</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">";;; Conway's game of life\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; (progn expr ...)\n"</span>
                <span class="o">+</span> <span class="s">";; =&gt; ((lambda () expr ...))\n"</span>
                <span class="o">+</span> <span class="s">"(defmacro progn (expr . rest)\n"</span>
                <span class="o">+</span> <span class="s">"  (list (cons 'lambda (cons () (cons expr rest)))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">"(defun list (x . y)\n"</span>
                <span class="o">+</span> <span class="s">"  (cons x y))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">"(defun not (x)\n"</span>
                <span class="o">+</span> <span class="s">"  (if x () t))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; (let var val body ...)\n"</span>
                <span class="o">+</span> <span class="s">";; =&gt; ((lambda (var) body ...) val)\n"</span>
                <span class="o">+</span> <span class="s">"(defmacro let (var val . body)\n"</span>
                <span class="o">+</span> <span class="s">"  (cons (cons 'lambda (cons (list var) body))\n"</span>
                <span class="o">+</span> <span class="s">"\t(list val)))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; (and e1 e2 ...)\n"</span>
                <span class="o">+</span> <span class="s">";; =&gt; (if e1 (and e2 ...))\n"</span>
                <span class="o">+</span> <span class="s">";; (and e1)\n"</span>
                <span class="o">+</span> <span class="s">";; =&gt; e1\n"</span>
                <span class="o">+</span> <span class="s">"(defmacro and (expr . rest)\n"</span>
                <span class="o">+</span> <span class="s">"  (if rest\n"</span>
                <span class="o">+</span> <span class="s">"      (list 'if expr (cons 'and rest))\n"</span>
                <span class="o">+</span> <span class="s">"    expr))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; (or e1 e2 ...)\n"</span>
                <span class="o">+</span> <span class="s">";; =&gt; (let &lt;tmp&gt; e1\n"</span>
                <span class="o">+</span> <span class="s">";;      (if &lt;tmp&gt; &lt;tmp&gt; (or e2 ...)))\n"</span>
                <span class="o">+</span> <span class="s">";; (or e1)\n"</span>
                <span class="o">+</span> <span class="s">";; =&gt; e1\n"</span>
                <span class="o">+</span> <span class="s">";;\n"</span>
                <span class="o">+</span> <span class="s">";; The reason to use the temporary variables is to avoid evaluating the\n"</span>
                <span class="o">+</span> <span class="s">";; arguments more than once.\n"</span>
                <span class="o">+</span> <span class="s">"(defmacro or (expr . rest)\n"</span>
                <span class="o">+</span> <span class="s">"  (if rest\n"</span>
                <span class="o">+</span> <span class="s">"      (let var (gensym)\n"</span>
                <span class="o">+</span> <span class="s">"           (list 'let var expr\n"</span>
                <span class="o">+</span> <span class="s">"                 (list 'if var var (cons 'or rest))))\n"</span>
                <span class="o">+</span> <span class="s">"    expr))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; (when expr body ...)\n"</span>
                <span class="o">+</span> <span class="s">";; =&gt; (if expr (progn body ...))\n"</span>
                <span class="o">+</span> <span class="s">"(defmacro when (expr . body)\n"</span>
                <span class="o">+</span> <span class="s">"  (cons 'if (cons expr (list (cons 'progn body)))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; (unless expr body ...)\n"</span>
                <span class="o">+</span> <span class="s">";; =&gt; (if expr () body ...)\n"</span>
                <span class="o">+</span> <span class="s">"(defmacro unless (expr . body)\n"</span>
                <span class="o">+</span> <span class="s">"  (cons 'if (cons expr (cons () body))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">";;; Numeric operators\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">"(defun &lt;= (e1 e2)\n"</span>
                <span class="o">+</span> <span class="s">"  (or (&lt; e1 e2)\n"</span>
                <span class="o">+</span> <span class="s">"      (= e1 e2)))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">";;; List operators\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";;; Applies each element of lis to fn, and returns their return values as a list.\n"</span>
                <span class="o">+</span> <span class="s">"(defun map (lis fn)\n"</span>
                <span class="o">+</span> <span class="s">"  (when lis\n"</span>
                <span class="o">+</span> <span class="s">"    (cons (fn (car lis))\n"</span>
                <span class="o">+</span> <span class="s">"\t  (map (cdr lis) fn))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Returns nth element of lis.\n"</span>
                <span class="o">+</span> <span class="s">"(defun nth (lis n)\n"</span>
                <span class="o">+</span> <span class="s">"  (if (= n 0)\n"</span>
                <span class="o">+</span> <span class="s">"      (car lis)\n"</span>
                <span class="o">+</span> <span class="s">"    (nth (cdr lis) (- n 1))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Returns the nth tail of lis.\n"</span>
                <span class="o">+</span> <span class="s">"(defun nth-tail (lis n)\n"</span>
                <span class="o">+</span> <span class="s">"  (if (= n 0)\n"</span>
                <span class="o">+</span> <span class="s">"      lis\n"</span>
                <span class="o">+</span> <span class="s">"    (nth-tail (cdr lis) (- n 1))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Returns a list consists of m .. n-1 integers.\n"</span>
                <span class="o">+</span> <span class="s">"(defun %iota (m n)\n"</span>
                <span class="o">+</span> <span class="s">"  (unless (&lt;= n m)\n"</span>
                <span class="o">+</span> <span class="s">"    (cons m (%iota (+ m 1) n))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Returns a list consists of 0 ... n-1 integers.\n"</span>
                <span class="o">+</span> <span class="s">"(defun iota (n)\n"</span>
                <span class="o">+</span> <span class="s">"  (%iota 0 n))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">";;; Main\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">"(define width 10)\n"</span>
                <span class="o">+</span> <span class="s">"(define height 10)\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Returns location (x, y)'s element.\n"</span>
                <span class="o">+</span> <span class="s">"(defun get (board x y)\n"</span>
                <span class="o">+</span> <span class="s">"  (nth (nth board y) x))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Returns true if location (x, y)'s value is \"@\".\n"</span>
                <span class="o">+</span> <span class="s">"(defun alive? (board x y)\n"</span>
                <span class="o">+</span> <span class="s">"  (and (&lt;= 0 x)\n"</span>
                <span class="o">+</span> <span class="s">"       (&lt; x height)\n"</span>
                <span class="o">+</span> <span class="s">"       (&lt;= 0 y)\n"</span>
                <span class="o">+</span> <span class="s">"       (&lt; y width)\n"</span>
                <span class="o">+</span> <span class="s">"       (eq (get board x y) '@)))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Print out the given board.\n"</span>
                <span class="o">+</span> <span class="s">"(defun print (board)\n"</span>
                <span class="o">+</span> <span class="s">"  (if (not board)\n"</span>
                <span class="o">+</span> <span class="s">"      '$\n"</span>
                <span class="o">+</span> <span class="s">"    (println (car board))\n"</span>
                <span class="o">+</span> <span class="s">"    (print (cdr board))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">"(defun count (board x y)\n"</span>
                <span class="o">+</span> <span class="s">"  (let at (lambda (x y)\n"</span>
                <span class="o">+</span> <span class="s">"            (if (alive? board x y) 1 0))\n"</span>
                <span class="o">+</span> <span class="s">"       (+ (at (- x 1) (- y 1))\n"</span>
                <span class="o">+</span> <span class="s">"          (at (- x 1) y)\n"</span>
                <span class="o">+</span> <span class="s">"          (at (- x 1) (+ y 1))\n"</span>
                <span class="o">+</span> <span class="s">"          (at x (- y 1))\n"</span>
                <span class="o">+</span> <span class="s">"          (at x (+ y 1))\n"</span>
                <span class="o">+</span> <span class="s">"          (at (+ x 1) (- y 1))\n"</span>
                <span class="o">+</span> <span class="s">"          (at (+ x 1) y)\n"</span>
                <span class="o">+</span> <span class="s">"          (at (+ x 1) (+ y 1)))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">"(defun next (board x y)\n"</span>
                <span class="o">+</span> <span class="s">"  (let c (count board x y)\n"</span>
                <span class="o">+</span> <span class="s">"       (if (alive? board x y)\n"</span>
                <span class="o">+</span> <span class="s">"           (or (= c 2) (= c 3))\n"</span>
                <span class="o">+</span> <span class="s">"         (= c 3))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">"(defun run (board)\n"</span>
                <span class="o">+</span> <span class="s">"  (while t\n"</span>
                <span class="o">+</span> <span class="s">"    (print board)\n"</span>
                <span class="o">+</span> <span class="s">"    (println '*)\n"</span>
                <span class="o">+</span> <span class="s">"    (let newboard (map (iota height)\n"</span>
                <span class="o">+</span> <span class="s">"                       (lambda (y)\n"</span>
                <span class="o">+</span> <span class="s">"                         (map (iota width)\n"</span>
                <span class="o">+</span> <span class="s">"                              (lambda (x)\n"</span>
                <span class="o">+</span> <span class="s">"                                (if (next board x y) '@ '_)))))\n"</span>
                <span class="o">+</span> <span class="s">"         (setq board newboard))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">"(run '((_ _ _ _ _ _ _ _ _ _)\n"</span>
                <span class="o">+</span> <span class="s">"       (_ _ _ _ _ _ _ _ _ _)\n"</span>
                <span class="o">+</span> <span class="s">"       (_ _ _ _ _ _ _ _ _ _)\n"</span>
                <span class="o">+</span> <span class="s">"       (_ _ _ _ _ _ _ _ _ _)\n"</span>
                <span class="o">+</span> <span class="s">"       (_ _ _ _ _ _ _ _ _ _)\n"</span>
                <span class="o">+</span> <span class="s">"       (_ _ _ _ _ _ _ _ _ _)\n"</span>
                <span class="o">+</span> <span class="s">"       (_ _ _ _ _ _ _ _ _ _)\n"</span>
                <span class="o">+</span> <span class="s">"       (_ @ @ @ _ _ _ _ _ _)\n"</span>
                <span class="o">+</span> <span class="s">"       (_ _ _ @ _ _ _ _ _ _)\n"</span>
                <span class="o">+</span> <span class="s">"       (_ _ @ _ _ _ _ _ _ _)))\n"</span><span class="o">;</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test15</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">";;; N-queens puzzle solver.\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">";;; The N queens puzzle is the problem of placing N chess queens on an N x N\n"</span>
                <span class="o">+</span> <span class="s">";;; chessboard so that no two queens attack each\n"</span>
                <span class="o">+</span> <span class="s">";;; other. http://en.wikipedia.org/wiki/Eight_queens_puzzle\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">";;; This program solves N-queens puzzle by depth-first backtracking.\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">";;; Basic macros\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">";;; Because the language does not have quasiquote, we need to construct an\n"</span>
                <span class="o">+</span> <span class="s">";;; expanded form using cons and list.\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; (progn expr ...)\n"</span>
                <span class="o">+</span> <span class="s">";; =&gt; ((lambda () expr ...))\n"</span>
                <span class="o">+</span> <span class="s">"(defmacro progn (expr . rest)\n"</span>
                <span class="o">+</span> <span class="s">"  (list (cons 'lambda (cons () (cons expr rest)))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">"(defun list (x . y)\n"</span>
                <span class="o">+</span> <span class="s">"  (cons x y))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">"(defun not (x)\n"</span>
                <span class="o">+</span> <span class="s">"  (if x () t))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; (let1 var val body ...)\n"</span>
                <span class="o">+</span> <span class="s">";; =&gt; ((lambda (var) body ...) val)\n"</span>
                <span class="o">+</span> <span class="s">"(defmacro let1 (var val . body)\n"</span>
                <span class="o">+</span> <span class="s">"  (cons (cons 'lambda (cons (list var) body))\n"</span>
                <span class="o">+</span> <span class="s">"\t(list val)))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; (and e1 e2 ...)\n"</span>
                <span class="o">+</span> <span class="s">";; =&gt; (if e1 (and e2 ...))\n"</span>
                <span class="o">+</span> <span class="s">";; (and e1)\n"</span>
                <span class="o">+</span> <span class="s">";; =&gt; e1\n"</span>
                <span class="o">+</span> <span class="s">"(defmacro and (expr . rest)\n"</span>
                <span class="o">+</span> <span class="s">"  (if rest\n"</span>
                <span class="o">+</span> <span class="s">"      (list 'if expr (cons 'and rest))\n"</span>
                <span class="o">+</span> <span class="s">"    expr))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; (or e1 e2 ...)\n"</span>
                <span class="o">+</span> <span class="s">";; =&gt; (let1 &lt;tmp&gt; e1\n"</span>
                <span class="o">+</span> <span class="s">";;      (if &lt;tmp&gt; &lt;tmp&gt; (or e2 ...)))\n"</span>
                <span class="o">+</span> <span class="s">";; (or e1)\n"</span>
                <span class="o">+</span> <span class="s">";; =&gt; e1\n"</span>
                <span class="o">+</span> <span class="s">";;\n"</span>
                <span class="o">+</span> <span class="s">";; The reason to use the temporary variables is to avoid evaluating the\n"</span>
                <span class="o">+</span> <span class="s">";; arguments more than once.\n"</span>
                <span class="o">+</span> <span class="s">"(defmacro or (expr . rest)\n"</span>
                <span class="o">+</span> <span class="s">"  (if rest\n"</span>
                <span class="o">+</span> <span class="s">"      (let1 var (gensym)\n"</span>
                <span class="o">+</span> <span class="s">"\t    (list 'let1 var expr\n"</span>
                <span class="o">+</span> <span class="s">"\t\t  (list 'if var var (cons 'or rest))))\n"</span>
                <span class="o">+</span> <span class="s">"    expr))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; (when expr body ...)\n"</span>
                <span class="o">+</span> <span class="s">";; =&gt; (if expr (progn body ...))\n"</span>
                <span class="o">+</span> <span class="s">"(defmacro when (expr . body)\n"</span>
                <span class="o">+</span> <span class="s">"  (cons 'if (cons expr (list (cons 'progn body)))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; (unless expr body ...)\n"</span>
                <span class="o">+</span> <span class="s">";; =&gt; (if expr () body ...)\n"</span>
                <span class="o">+</span> <span class="s">"(defmacro unless (expr . body)\n"</span>
                <span class="o">+</span> <span class="s">"  (cons 'if (cons expr (cons () body))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">";;; Numeric operators\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">"(defun &lt;= (e1 e2)\n"</span>
                <span class="o">+</span> <span class="s">"  (or (&lt; e1 e2)\n"</span>
                <span class="o">+</span> <span class="s">"      (= e1 e2)))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">";;; List operators\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Applies each element of lis to pred. If pred returns a true value, terminate\n"</span>
                <span class="o">+</span> <span class="s">";; the evaluation and returns pred's return value. If all of them return (),\n"</span>
                <span class="o">+</span> <span class="s">";; returns ().\n"</span>
                <span class="o">+</span> <span class="s">"(defun any (lis pred)\n"</span>
                <span class="o">+</span> <span class="s">"  (when lis\n"</span>
                <span class="o">+</span> <span class="s">"    (or (pred (car lis))\n"</span>
                <span class="o">+</span> <span class="s">"\t(any (cdr lis) pred))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";;; Applies each element of lis to fn, and returns their return values as a list.\n"</span>
                <span class="o">+</span> <span class="s">"(defun map (lis fn)\n"</span>
                <span class="o">+</span> <span class="s">"  (when lis\n"</span>
                <span class="o">+</span> <span class="s">"    (cons (fn (car lis))\n"</span>
                <span class="o">+</span> <span class="s">"\t  (map (cdr lis) fn))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Returns nth element of lis.\n"</span>
                <span class="o">+</span> <span class="s">"(defun nth (lis n)\n"</span>
                <span class="o">+</span> <span class="s">"  (if (= n 0)\n"</span>
                <span class="o">+</span> <span class="s">"      (car lis)\n"</span>
                <span class="o">+</span> <span class="s">"    (nth (cdr lis) (- n 1))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Returns the nth tail of lis.\n"</span>
                <span class="o">+</span> <span class="s">"(defun nth-tail (lis n)\n"</span>
                <span class="o">+</span> <span class="s">"  (if (= n 0)\n"</span>
                <span class="o">+</span> <span class="s">"      lis\n"</span>
                <span class="o">+</span> <span class="s">"    (nth-tail (cdr lis) (- n 1))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Returns a list consists of m .. n-1 integers.\n"</span>
                <span class="o">+</span> <span class="s">"(defun %iota (m n)\n"</span>
                <span class="o">+</span> <span class="s">"  (unless (&lt;= n m)\n"</span>
                <span class="o">+</span> <span class="s">"    (cons m (%iota (+ m 1) n))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Returns a list consists of 0 ... n-1 integers.\n"</span>
                <span class="o">+</span> <span class="s">"(defun iota (n)\n"</span>
                <span class="o">+</span> <span class="s">"  (%iota 0 n))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Returns a new list whose length is len and all members are init.\n"</span>
                <span class="o">+</span> <span class="s">"(defun make-list (len init)\n"</span>
                <span class="o">+</span> <span class="s">"  (unless (= len 0)\n"</span>
                <span class="o">+</span> <span class="s">"    (cons init (make-list (- len 1) init))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Applies fn to each element of lis.\n"</span>
                <span class="o">+</span> <span class="s">"(defun for-each (lis fn)\n"</span>
                <span class="o">+</span> <span class="s">"  (or (not lis)\n"</span>
                <span class="o">+</span> <span class="s">"      (progn (fn (car lis))\n"</span>
                <span class="o">+</span> <span class="s">"\t     (for-each (cdr lis) fn))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">";;; N-queens solver\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Creates size x size list filled with symbol \"x\".\n"</span>
                <span class="o">+</span> <span class="s">"(defun make-board (size)\n"</span>
                <span class="o">+</span> <span class="s">"  (map (iota size)\n"</span>
                <span class="o">+</span> <span class="s">"       (lambda (_)\n"</span>
                <span class="o">+</span> <span class="s">"\t (make-list size 'x))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Returns location (x, y)'s element.\n"</span>
                <span class="o">+</span> <span class="s">"(defun get (board x y)\n"</span>
                <span class="o">+</span> <span class="s">"  (nth (nth board x) y))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Set symbol \"@\" to location (x, y).\n"</span>
                <span class="o">+</span> <span class="s">"(defun set (board x y)\n"</span>
                <span class="o">+</span> <span class="s">"  (setcar (nth-tail (nth board x) y) '@))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Set symbol \"x\" to location (x, y).\n"</span>
                <span class="o">+</span> <span class="s">"(defun clear (board x y)\n"</span>
                <span class="o">+</span> <span class="s">"  (setcar (nth-tail (nth board x) y) 'x))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Returns true if location (x, y)'s value is \"@\".\n"</span>
                <span class="o">+</span> <span class="s">"(defun set? (board x y)\n"</span>
                <span class="o">+</span> <span class="s">"  (eq (get board x y) '@))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Print out the given board.\n"</span>
                <span class="o">+</span> <span class="s">"(defun print (board)\n"</span>
                <span class="o">+</span> <span class="s">"  (if (not board)\n"</span>
                <span class="o">+</span> <span class="s">"      '$\n"</span>
                <span class="o">+</span> <span class="s">"    (println (car board))\n"</span>
                <span class="o">+</span> <span class="s">"    (print (cdr board))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Returns true if we cannot place a queen at position (x, y), assuming that\n"</span>
                <span class="o">+</span> <span class="s">";; queens have already been placed on each row from 0 to x-1.\n"</span>
                <span class="o">+</span> <span class="s">"(defun conflict? (board x y)\n"</span>
                <span class="o">+</span> <span class="s">"  (any (iota x)\n"</span>
                <span class="o">+</span> <span class="s">"       (lambda (n)\n"</span>
                <span class="o">+</span> <span class="s">"\t (or\n"</span>
                <span class="o">+</span> <span class="s">"\t  ;; Check if there's no conflicting queen upward\n"</span>
                <span class="o">+</span> <span class="s">"\t  (set? board n y)\n"</span>
                <span class="o">+</span> <span class="s">"\t  ;; Upper left\n"</span>
                <span class="o">+</span> <span class="s">"\t  (let1 z (+ y (- n x))\n"</span>
                <span class="o">+</span> <span class="s">"\t\t(and (&lt;= 0 z)\n"</span>
                <span class="o">+</span> <span class="s">"\t\t     (set? board n z)))\n"</span>
                <span class="o">+</span> <span class="s">"\t  ;; Upper right\n"</span>
                <span class="o">+</span> <span class="s">"\t  (let1 z (+ y (- x n))\n"</span>
                <span class="o">+</span> <span class="s">"\t\t(and (&lt; z board-size)\n"</span>
                <span class="o">+</span> <span class="s">"\t\t     (set? board n z)))))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";; Find positions where we can place queens at row x, and continue searching for\n"</span>
                <span class="o">+</span> <span class="s">";; the next row.\n"</span>
                <span class="o">+</span> <span class="s">"(defun %solve (board x)\n"</span>
                <span class="o">+</span> <span class="s">"  (if (= x board-size)\n"</span>
                <span class="o">+</span> <span class="s">"      ;; Problem solved\n"</span>
                <span class="o">+</span> <span class="s">"      (progn (print board)\n"</span>
                <span class="o">+</span> <span class="s">"\t     (println '$))\n"</span>
                <span class="o">+</span> <span class="s">"    (for-each (iota board-size)\n"</span>
                <span class="o">+</span> <span class="s">"\t      (lambda (y)\n"</span>
                <span class="o">+</span> <span class="s">"\t\t(unless (conflict? board x y)\n"</span>
                <span class="o">+</span> <span class="s">"\t\t  (set board x y)\n"</span>
                <span class="o">+</span> <span class="s">"\t\t  (%solve board (+ x 1))\n"</span>
                <span class="o">+</span> <span class="s">"\t\t  (clear board x y))))))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">"(defun solve (board)\n"</span>
                <span class="o">+</span> <span class="s">"  (println 'start)\n"</span>
                <span class="o">+</span> <span class="s">"  (%solve board 0)\n"</span>
                <span class="o">+</span> <span class="s">"  (println 'done))\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">";;; Main\n"</span>
                <span class="o">+</span> <span class="s">";;;\n"</span>
                <span class="o">+</span> <span class="s">"\n"</span>
                <span class="o">+</span> <span class="s">"(define board-size 8)\n"</span>
                <span class="o">+</span> <span class="s">"(define board (make-board board-size))\n"</span>
                <span class="o">+</span> <span class="s">"(solve board)\n"</span><span class="o">;</span>
        <span class="n">call</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">call</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
        <span class="n">MiniLisp</span> <span class="n">parser</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MiniLisp</span><span class="o">(</span><span class="k">new</span> <span class="n">StringReader</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
        <span class="n">parser</span><span class="o">.</span><span class="na">Input</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>


  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">3.λ｜形而下技术博客</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              3.λ｜形而下技术博客
            
            </li>
            
            <li><a href="mailto:alenym@qq.com">alenym@qq.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/yanggeorge"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">yanggeorge</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>这里只关注技术实现，用代码说话。</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
